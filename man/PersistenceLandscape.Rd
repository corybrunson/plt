% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PersistenceLandscape.R, R/RcppExports.R
\name{summary.Rcpp_PersistenceLandscape}
\alias{summary.Rcpp_PersistenceLandscape}
\alias{print.summary.Rcpp_PersistenceLandscape}
\alias{as.vector.Rcpp_PersistenceLandscape}
\alias{as.data.frame.Rcpp_PersistenceLandscape}
\alias{PersistenceLandscape}
\alias{Rcpp_PersistenceLandscape-class}
\title{Exported C++ Class 'PersistenceLandscape'}
\usage{
\method{summary}{Rcpp_PersistenceLandscape}(object, ...)

\method{print}{summary.Rcpp_PersistenceLandscape}(x, digits = max(1L, getOption("digits") - 3L), ...)

\method{as.vector}{Rcpp_PersistenceLandscape}(x, mode = "any")

\method{as.data.frame}{Rcpp_PersistenceLandscape}(x, row.names = NULL, optional = FALSE, ...)
}
\arguments{
\item{object}{an object for which a summary is desired.}

\item{...}{additional arguments affecting the summary produced.}

\item{x}{a result of the \emph{default} method of \code{summary()}.}

\item{digits}{integer, used for number formatting with
    \code{\link[base]{signif}()} (for \code{summary.default}) or
    \code{\link[base]{format}()} (for \code{summary.data.frame}).  In
    \code{summary.default}, if not specified (i.e.,
    \code{\link[base]{missing}(.)}), \code{signif()} will \emph{not} be called
    anymore (since \R >= 3.4.0, where the default has been changed to
    only round in the \code{print} and \code{format} methods).}

\item{mode}{character string naming an atomic mode or
    \code{"list"} or \code{"expression"} or (except for \code{vector})
    \code{"any"}.  Currently, \code{is.vector()} allows any type (see
    \code{\link[base]{typeof}}) for \code{mode}, and when mode is not
    \code{"any"}, \code{is.vector(x, mode)} is almost the same as
    \code{typeof(x) == mode}.}

\item{row.names}{\code{NULL} or a character vector giving the row
    names for the data frame.  Missing values are not allowed.}

\item{optional}{logical. If \code{TRUE}, setting row names and
    converting column names (to syntactic names: see
    \code{\link[base]{make.names}}) is optional.  Note that all of \R's
    \pkg{base} package \code{as.data.frame()} methods use
    \code{optional} only for column names treatment, basically with the
    meaning of \code{\link[base]{data.frame}(*, check.names = !optional)}.
    See also the \code{make.names} argument of the \code{matrix} method.}
}
\description{
Export, and create and manipulate objects of, the
PersistenceLandscape' C++ class.
}
\details{
The C++ class 'PersistenceLandscape' is exposed as the S4 class
'Rcpp_PersistenceLandscape' via the \code{RCPP_MODULE()} macro provided by
\strong{\link[Rcpp:Rcpp-package]{Rcpp}}. See
\url{https://github.com/r-pkg-examples/rcpp-modules-student} for an
introduction. New objects should be created from persistence data
(diagrams) using \code{\link[=landscape]{landscape()}}.
}
\section{Fields}{

\describe{
\item{\code{new}}{Constructor.}

\item{\code{exact}}{Representation of the underlying PL.}

\item{\code{min_x}}{Infimum (left endpoint) of the support of a discrete PL.}

\item{\code{max_x}}{Supremum (right endpoint) of the support of a discrete PL.}

\item{\code{dx}}{Resolution of the representation of a discrete PL.}
}}

\examples{

# double matrix
pl <- new(
  PersistenceLandscape,
  cbind(c(0, 0, 1, 2), c(1.5, 2.5, 3.5, 4.5)),
  TRUE,
  0, 10, .01
)
pl$isExact()
pl$xMin()
pl$xMax()
pl$xBy()
pl$getInternal()
print(pl)
summary(pl)

dim(pl$toDiscrete()$getInternal())
length(as.vector(pl))
as.data.frame(pl)

pl2 <- pl$scale(2)
pl2$getInternal()
pl3 <- pl$add(pl2)
pl3$getInternal()

# integer matrix
pl <- new(
  PersistenceLandscape,
  cbind(c(0L, 0L, 1L, 2L), c(2L, 3L, 4L, 5L)),
  TRUE,
  0, 10, .01
)
pl$getInternal()
print(pl)

# discrete landscape
pl <- new(
  PersistenceLandscape,
  cbind(c(0, 0, 1, 2), c(1.5, 2.5, 3.5, 4.5)),
  FALSE,
  0, 5, .5
)
pl$xBy()
pl$getInternal()
print(pl)

dim(pl$toDiscrete()$getInternal())
length(as.vector(pl))
as.data.frame(pl)

pl2 <- pl$scale(2)
pl2$isExact()
pl2$xBy()
pl2$getInternal()
show(pl2)

(pl3 <- pl$add(pl2))
pl3$getInternal()
pl3$xBy()
}
