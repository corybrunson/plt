% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/landscape.R
\name{landscape}
\alias{landscape}
\alias{pl_is_exact}
\alias{pl_type}
\alias{pl_num_levels}
\alias{pl_limits}
\alias{pl_support}
\alias{pl_delimit}
\alias{pl_discretize}
\title{Persistence Landscapes}
\usage{
landscape(
  pd,
  degree = NULL,
  exact = FALSE,
  xmin = NULL,
  xmax = NULL,
  xby = NULL
)

pl_is_exact(pl)

pl_type(pl)

pl_num_levels(pl)

pl_limits(pl)

pl_support(pl)

pl_delimit(pl, xmin = NULL, xmax = NULL, xby = NULL)

pl_discretize(pl)
}
\arguments{
\item{pd}{Persistence data (or diagram), stored as a 2-column matrix, as a
'\link{persistence}' object, or in a format coercible to 'persistence'.}

\item{degree}{Non-negative integer; if input is a persistence diagram object,
then the dimension for which to compute a landscape. (For degree \eqn{d},
the \eqn{(d+1)}th matrix in the list will be selected.)}

\item{exact}{Set to \code{TRUE} for exact representation, \code{FALSE} (default) for
discrete.}

\item{xmin, xmax}{Domain thresholds for discrete PL; if not specified, then
taken to be the support of the PL constructed from the data or the internal
values of the 'Rcpp_PersistenceLandscape' object.}

\item{xby}{Domain grid diameter for discrete PL; if not specified, then set to
the power of 10 that yields between 100 and 1000 intervals.}

\item{pl}{A persistence landscape as returned by \code{landscape()}.}
}
\value{
\code{landscape()} returns a persistence landscape (an object of S4 class
'Rcpp_PersistenceLandscape'). Other functions return summary information
about such an object.
}
\description{
Compute persistence landscapes from persistence data.
}
\details{
\code{landscape()} is a wrapper around the S4 class constructor
\verb{[methods:new()]}. The \verb{pl_*()} helper functions take a persistence
landscape as returned by \code{landscape()} and return its representation
(\code{pl_is_exact()} and \code{pl_type()}), the number of levels
(\code{pl_num_levels()}), the endpoints of its internal representation
(excluding infinities) (\code{pl_limits()}), and the endpoints of its support,
i.e. of the points at which its value is nonzero (\code{pl_support()}).
}
\examples{

# sample points
points <- tdaunif::sample_torus_tube(100, 5)

# compute persistent homology
(pd <- ripserr::vietoris_rips(points, dim = 2L, threshold = 1))

# compute persistence landscapes for 0-cycles
(pl <- landscape(pd, degree = 1, exact = TRUE))

# first landscape layer
print(pl$getInternal()[[1L]])
# plot all landscape layers
plot(pl)

# coerce to discrete at different resolutions
plot(pl, xlim = c(0, .5))
pl <- pl_delimit(pl, xmin = 0, xmax = .5, xby = .01)
pl_ <- pl_discretize(pl)
plot(pl_)
pl <- pl_delimit(pl, xmin = 0, xmax = .5, xby = .001)
pl_ <- pl_discretize(pl)
plot(pl_)

# ensure grid when discretizing
pl_cut <- pl_discretize(pl_delimit(pl, xby = 0.1))
pl_cut$getInternal()[1, , 1]
pl_cut <- pl_discretize(pl_delimit(pl, xmin = 0, xmax = pi, xby = 0.1))
pl_cut$getInternal()[1, , 1]

# sample points
points <- tdaunif::sample_torus_tube(60L, 2.5)

# compute persistent homology
pd <- TDA::ripsDiag(points, maxdimension = 2L, maxscale = 3)
head(pd$diagram)

# compute persistence landscape for 1-dimensional cycles
pl <- landscape(pd, degree = 1L)
print(pl)

# landscape dimensions
print(dim(pl$getInternal()))
# landscape values
print(head(pl$getInternal()))
# plot landscape
plot(pl)

# custom parameters
pl <- landscape(pd, degree = 1L, xby = 0.1, xmax = 2)
print(pl)
plot(pl)
}
\seealso{
\linkS4class{Rcpp_PersistenceLandscape} for the exported C++ class.
}
