% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/landscape.R
\name{pl_new}
\alias{pl_new}
\alias{pl_is_exact}
\alias{pl_type}
\alias{pl_num_levels}
\alias{pl_limits}
\alias{pl_support}
\alias{pl_delimit}
\alias{pl_discretize}
\title{Persistence Landscapes}
\usage{
pl_new(pd, degree = NULL, exact = FALSE, xmin = NULL, xmax = NULL, xby = NULL)

pl_is_exact(pl)

pl_type(pl)

pl_num_levels(pl)

pl_limits(pl)

pl_support(pl)

pl_delimit(pl, xmin = NULL, xmax = NULL, xby = NULL)

pl_discretize(pl)
}
\arguments{
\item{pd}{Persistence data (or diagram), stored as a 2-column matrix, as a
'\link{persistence}' object, or in a format coercible to 'persistence'.}

\item{degree}{Non-negative integer; if input is a persistence diagram object,
then the dimension for which to compute a landscape. (For degree \eqn{d},
the \eqn{(d+1)}th matrix in the list will be selected.)}

\item{exact}{Set to \code{TRUE} for exact representation, \code{FALSE} (default) for
discrete.}

\item{xmin, xmax}{Domain thresholds for discrete PL; if not specified, then
taken to be the support of the PL constructed from the data or the internal
values of the 'Rcpp_PersistenceLandscape' object.}

\item{xby}{Domain grid diameter for discrete PL; if not specified, then set
to the power of 10 that yields between 100 and 1000 intervals.}

\item{pl}{A persistence landscape as returned by \code{pl_new()}.}
}
\value{
\code{pl_new()} returns a persistence landscape (an object of S4 class
'Rcpp_PersistenceLandscape'). Other functions return summary information
about such an object.
}
\description{
Compute persistence landscapes from persistence data.
}
\details{
\code{pl_new()} is a wrapper around the S4 class constructor
\verb{[methods:new()]}. The \verb{pl_*()} helper functions query a persistence
landscape as returned by \code{pl_new()} for specific information or manipulate
its internal representation.

Use \code{pl_is_exact()} and \code{pl_type()} to get a landscape's internal
representation, \code{pl_num_levels()} its number of levels, \code{pl_limits()} the
endpoints of its internal representation (excluding infinities), and
\code{pl_support()} the infimum and supremum of its support (the points at which
its value is nonzero).

Use \code{pl_delimit()} to change the limits of a PL and \code{pl_discretize()} to
convert an exact landscape to a discrete one (using its internally-stored
range and resolution).
}
\examples{

# sample points
points <- tdaunif::sample_torus_tube(100, 5)

# compute persistent homology
(pd <- ripserr::vietoris_rips(points, dim = 2L, threshold = 1))

# compute persistence landscapes for 0-cycles
(pl <- pl_new(pd, degree = 1, exact = TRUE))

# first landscape layer
print(pl$getInternal()[[1L]])
# plot all landscape layers
plot(pl)

# coerce to discrete at different resolutions
plot(pl, xlim = c(0, .5))
pl <- pl_delimit(pl, xmin = 0, xmax = .5, xby = .01)
pl_ <- pl_discretize(pl)
plot(pl_)
pl <- pl_delimit(pl, xmin = 0, xmax = .5, xby = .001)
pl_ <- pl_discretize(pl)
plot(pl_)

# ensure grid when discretizing
pl_cut <- pl_discretize(pl_delimit(pl, xby = 0.1))
pl_cut$getInternal()[1, , 1]
pl_cut <- pl_discretize(pl_delimit(pl, xmin = 0, xmax = pi, xby = 0.1))
pl_cut$getInternal()[1, , 1]

# sample points
points <- tdaunif::sample_torus_tube(60L, 2.5)

# compute persistent homology
pd <- TDA::ripsDiag(points, maxdimension = 2L, maxscale = 3)
head(pd$diagram)

# compute persistence landscape for 1-dimensional cycles
pl <- pl_new(pd, degree = 1L)
print(pl)

# landscape dimensions
print(dim(pl$getInternal()))
# landscape values
print(head(pl$getInternal()))
# plot landscape
plot(pl)

# custom parameters
pl <- pl_new(pd, degree = 1L, xby = 0.1, xmax = 2)
print(pl)
plot(pl)
}
\seealso{
\linkS4class{Rcpp_PersistenceLandscape} for the exported C++ class.
}
