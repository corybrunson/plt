% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/algebra.R
\name{algebra}
\alias{algebra}
\alias{pl_t}
\alias{pl_to_vector}
\alias{pl_to_matrix}
\alias{pl_from_vector}
\alias{pl_from_matrix}
\title{Linear Algebra with Persistence Landscapes}
\usage{
pl_t(pl)

pl_to_vector(pl, num_levels = pl_num_levels(pl))

pl_to_matrix(...)

pl_from_vector(x, t_vals = NULL, drop_levels = FALSE)

pl_from_matrix(x, t_vals = NULL, drop_levels = FALSE)
}
\arguments{
\item{pl}{A persistence landscape as returned by \code{pl_new()}.}

\item{num_levels}{Number of levels to vectorize; may me more or less than
\code{pl_num_levels(pl)}.}

\item{...}{Persistence landscapes or lists of persistence landscapes.}

\item{x}{A numeric vector, optionally with an attribute \code{"t_vals"} whose
length divides that of \code{x}, but with no other attributes.}

\item{t_vals}{A numeric vector of equally-spaced values assumed to be the
grid support of a discrete persistence landscape.}

\item{drop_levels}{Logical; whether to omit levels that are empty in all PLs.}
}
\value{
\code{pl_t()} returns a numeric vector containing the grid of a
discrete persistence landscape. \code{pl_to_vector()} returns a numeric
vector with a \code{"t_vals"} attribute to reconstruct the discrete
landscape. \code{pl_to_matrix()} returns a matrix of such vectorizations.
\code{pl_from_vector()} returns a persistence landscape with class
"Rcpp_PersistenceLandscape", and \code{pl_from_matrix()} returns a list of
such persistence landscapes.
}
\description{
Convert between persistence landscapes and their vectorizations,
and perform linear algebra on vectorized persistence landscapes.
}
\details{
\code{pl_t()} extracts the common grid of \eqn{t}-values, discretizing
exact landscapes on the fly.

\code{pl_to_vector()} pad/truncates levels and flattens a persistence landscape to a
numeric vector; the grid is stored in the \code{"t_vals"} attribute.

\code{pl_to_matrix()} â€“ standardizes persistence landscapes by coordinating
resolution, limits, and level count across multiple landscapes and then bind
their vectorizations row-wise into a matrix (grid in \code{"t_vals"} attribute).

\code{pl_from_vector()} rebuilds one landscape from a flattened vector + grid,
optionally dropping empty levels.

\code{pl_from_matrix()} applies \code{pl_from_vector()} row-wise to turn a matrix
back into a list of landscapes.
}
\examples{

par(mfrow = c(2L, 2L), mar = rep(.5, 4))

# example PLs
x <- tdaunif::sample_klein_flat(60, ar = 2)
pd <- ripserr::vietoris_rips(x, dim = 1L, threshold = 2)
pl_e <- pl_new(pd, degree = 1L, exact = TRUE)
pl_d <- pl_new(pd, degree = 1L, exact = FALSE, xmax = 2, xby = 0.05)
plot(pl_e, xaxt = "n", yaxt = "n")
plot(pl_d, xaxt = "n", yaxt = "n")

# vectorize PLs
vec_e <- pl_to_matrix(pl_e)
vec_d <- pl_to_matrix(pl_d)
length(vec_e)
attributes(vec_e)
length(vec_d)
attributes(vec_d)

# de-vectorized PL
pl_e_ <- pl_from_matrix(vec_e)
plot(pl_e_, xaxt = "n", yaxt = "n")
pl_d_ <- pl_from_matrix(vec_d)
plot(pl_d_, xaxt = "n", yaxt = "n")

par(mfrow = c(1L, 1L), mar = c(5.1, 4.1, 4.1, 2.1))

# vectorize a list
pl_lst <- list(pl_e, pl_discretize(pl_delimit(pl_e, xby = 0.05)), pl_d)
m <- pl_to_matrix(pl_lst)
# de-vectorize the matrix
pl_from_matrix(m)
pl_from_matrix(m, drop_levels = TRUE)
}
\seealso{
\link{arithmetic}, \link{analysis}, \link{inference} for other landscape functions.
}
