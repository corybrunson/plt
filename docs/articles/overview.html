<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Exploratory and Predictive Analysis • plt</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Exploratory and Predictive Analysis">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">plt</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.0.0.9999</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/overview.html">Exploratory and Predictive Analysis</a>
    </li>
    <li>
      <a href="../articles/toy-example.html">Analysis of a Toy Example</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Exploratory and Predictive Analysis</h1>
                        <h4 data-toc-skip class="author">James Golabek,
Aidan Bryant, Jason Cory Brunson, Johnathan Bush, Iryna Hartsock, Peter
Bubenik</h4>
            
      

      <div class="hidden name"><code>overview.Rmd</code></div>

    </div>

    
    
<p>The goal of <strong>Topological data analysis</strong> (TDA) is to
analyze and measure the global topological features of data. The
persistence diagram, a common topological summary, lacks key properties
to make it conformable for statistical hypothesis testing and machine
learning. Persistence landscapes, introduced by Bubenik (2015)<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, are a
vectorization of persistence diagrams. In this vignette, we will show
how {plt} supports the computation of persistence landscapes, and both
exploratory and predictive analysis. This vignette is based on Peter
Bubenik’s TDA labs<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<p>Applications of TDA often proceed along the following steps:</p>
<ol style="list-style-type: decimal">
<li>Represent a sample of data as a point cloud.</li>
<li>Construct a filtered simplicial complex on the point cloud.</li>
<li>Obtain the persistence module by taking the simplicial homology of
the filtration.</li>
<li>Represent the persistence model as a persistence diagram.</li>
<li>Vectorize the persistence diagram to obtain analysis-ready
features.</li>
<li>Use the features in hypothesis testing or machine learning.</li>
</ol>
<p>This vignette will include dimension reduction, two-sample hypothesis
testing, and supervised classification as applications of TDA.</p>
<div class="section level3">
<h3 id="interoperability">Interoperability<a class="anchor" aria-label="anchor" href="#interoperability"></a>
</h3>
<p>{plt} is designed to be used with other TDA packages such as those
loaded below.</p>
<p>The <a href="https://github.com/tdaverse/tdaunif" class="external-link">{tdaunif}</a>
package provides tools to take uniform random samples from simple
manifolds and is commonly used for testing TDA tools. The <a href="https://cran.r-project.org/package=TDA" class="external-link">{TDA}</a> package contains
various tools for TDA, including functions to compute persistence data
from point clouds and distance matrices. We use the
<code><a href="https://rdrr.io/pkg/TDA/man/alphaComplexDiag.html" class="external-link">alphaComplexDiag()</a></code> function to obtain the birth and death
values of the alpha complex persistence module.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># for manifold samples</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://tdaverse.github.io/tdaunif/" class="external-link">tdaunif</a></span><span class="op">)</span></span>
<span><span class="co"># for alpha shapes</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">alphahull</span><span class="op">)</span></span>
<span><span class="co"># for persistent homology</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">TDA</span><span class="op">)</span></span>
<span><span class="co"># for persistence landscapes!</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">plt</span><span class="op">)</span></span>
<span><span class="co"># for support vector machines</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">e1071</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="persistent-homology-of-point-clouds">Persistent Homology of Point Clouds<a class="anchor" aria-label="anchor" href="#persistent-homology-of-point-clouds"></a>
</h2>
<p>To begin, we create a simple point cloud on which we will illustrate
how to use {plt}. We noisily sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>60</mn><annotation encoding="application/x-tex">60</annotation></semantics></math>
points in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math>
from a figure eight, the lemniscate of Gerono.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">120246L</span><span class="op">)</span></span>
<span><span class="va">pc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tdaverse.github.io/tdaunif/reference/lemniscates.html" class="external-link">sample_lemniscate_gerono</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">60</span>, sd <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pc</span>, asp <span class="op">=</span> <span class="fl">1</span>, pch <span class="op">=</span> <span class="fl">16L</span>, main <span class="op">=</span> <span class="st">"Figure Eight Point Cloud"</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-3-1.png" width="700" style="display: block; margin: auto;"></p>
<p>From our point set, we would like to generate more topologically
informative data. We construct a <strong>simplicial complex</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>,
which is a set of <strong>simplices</strong>. A
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-simplex</em>
is a single point, a
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-simplex</em>
is an edge or line segment, a
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-simplex</em>
is a triangle, and a
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>-simplex</em>
is a tetrahedron.</p>
<p>There are different formulations for constructing simplicial
complexes that have their own advantages and disadvantages. We will
utilize the <strong>alpha complex</strong> as it captures the underlying
structure of the data accurately and is more computationally efficient
than other methods.</p>
<p>By applying the alpha complex with various radii (scale), we create a
<strong>filtered simplicial complex</strong> or
<strong>filtration</strong>, which is a nested sequence of simplicial
complexes:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>0</mn></msub><mo>⊂</mo><msub><mi>K</mi><mn>1</mn></msub><mo>⊂</mo><msub><mi>K</mi><mn>2</mn></msub><mo>⊂</mo><mi>⋯</mi><mo>⊂</mo><msub><mi>K</mi><mi>n</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
K_0 \subset K_1 \subset K_2 \subset \cdots\subset K_n,
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></mrow><annotation encoding="application/x-tex">n \in \mathbb{N}</annotation></semantics></math>
is the number of simplicial complexes in the filtration. For any pair of
adjacent terms (simplicial complexes) in the filtration, the preceding
term is a <strong>subcomplex</strong> of the succeeding term.</p>
<p>The plots below illustrate a filtration using alpha shapes (which
closely resemble alpha complexes) at six levels of its distance
threshold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>α</mi></msub><annotation encoding="application/x-tex">\epsilon_\alpha</annotation></semantics></math>.
As
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>α</mi></msub><annotation encoding="application/x-tex">\epsilon_\alpha</annotation></semantics></math>
increases, the number of connected components and loops changes.
However, some topological features, such as the two lobes of the figure
eight, persist throughout many values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>α</mi></msub><annotation encoding="application/x-tex">\epsilon_\alpha</annotation></semantics></math>.</p>
<p><img src="overview_files/figure-html/unnamed-chunk-4-1.png" width="700" style="display: block; margin: auto;"></p>
<div class="section level3">
<h3 id="compute-persistence-data">Compute Persistence Data<a class="anchor" aria-label="anchor" href="#compute-persistence-data"></a>
</h3>
<p>The filtration provides a mathematical structure for analyzing the
global topological features of a point cloud. For each simplicial
complex within the filtration, we apply <strong>simplicial
homology</strong> to classify them using Betti numbers. The
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>k</mi><mtext mathvariant="normal">th</mtext></msup><annotation encoding="application/x-tex">k^{\text{th}}</annotation></semantics></math>
Betti number
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\beta_k</annotation></semantics></math></strong>
counts the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-dimensional
features of a simplicial complex.
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\beta_0</annotation></semantics></math></strong>
counts the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-dimensional
connected components,
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math></strong>
counts the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-dimensional
loops, and
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\beta_2</annotation></semantics></math></strong>
counts the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>-dimensional
cavities.</p>
<p>Applying simplicial homology to the filtration, we obtain a sequence
of vector spaces and linear maps called a <strong>persistence
module</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>⋯</mi><mo>→</mo><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
H_k(K_0) \rightarrow H_k(K_1) \rightarrow H_k(K_2) \rightarrow \cdots  \rightarrow H_k(K_n).
</annotation></semantics></math> The persistence module tracks the
<em>lifetime</em> of features throughout the <em>time span</em> of the
filtration. The <em>birth</em> value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>
of a feature is when it first appears in the persistence module. The
<em>death</em> value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
of a feature is when it disappears. A topological feature with a long
lifetime
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">d-b</annotation></semantics></math>
is called a <em>persistent</em> feature.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/TDA/man/alphaComplexDiag.html" class="external-link">alphaComplexDiag</a></span><span class="op">(</span><span class="va">pc</span>, maxdimension <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">$</span><span class="va">diagram</span></span>
<span></span>
<span><span class="co"># birth and death values have been squared, so take the square root</span></span>
<span><span class="va">pd</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">pd</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>The <code>pd</code> object stores the birth and death values for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
dimension features across the alpha filtration.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span></span>
<span><span class="co">#&gt;      dimension Birth     Death</span></span>
<span><span class="co">#&gt; [1,]         0     0       Inf</span></span>
<span><span class="co">#&gt; [2,]         0     0 0.1490153</span></span>
<span><span class="co">#&gt; [3,]         0     0 0.1417039</span></span>
<span><span class="co">#&gt; [4,]         0     0 0.1220746</span></span>
<span><span class="co">#&gt; [5,]         0     0 0.1173572</span></span>
<span><span class="co">#&gt; [6,]         0     0 0.1129086</span></span></code></pre></div>
<!--
### Persistence Barcode
A persistence barcode is a topological summary that visualizes the lifetimes of topological features. The x-axis represents the time span of the filtration. The below barcode shows that two features in homology dimension-one persist longer than the other features in dimension one. These two persistent features correspond to the two holes in $X$.


``` r
plot(pd, diagLim = c(0, 0.5), barcode = TRUE)
legend(0.3, 25, c('Homology in degree 0','Homology in degree 1'),
col = c(1,2), pch = c(19,2), cex = .8, pt.lwd = 2)
```

<img src="overview_files/figure-html/unnamed-chunk-7-1.png" width="700" />
-->
</div>
<div class="section level3">
<h3 id="persistence-diagram">Persistence Diagram<a class="anchor" aria-label="anchor" href="#persistence-diagram"></a>
</h3>
<p>The persistence diagram is a topological summary that visualizes the
birth and death times of topological features. The diagram has axes
birth &amp; death, and a line
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">d = b</annotation></semantics></math>.
For any point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b,d)</annotation></semantics></math>,
we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>−</mo><mi>b</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d-b \geq 0</annotation></semantics></math>.
Graphically, each point is on or above the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">d = b</annotation></semantics></math>
line. Points close to or on this line are ephemeral features because
they die shortly or immediately after being born.</p>
<p>In the persistence diagram below, three features stand out. Two are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-dimensional
features distinguished by their distance from the line
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">d = b</annotation></semantics></math>.
These persistence features represent the two lobes of the figure eight.
We also observe a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-dimensional
feature with infinite persistence because there must always be the one
connected component that includes the entire dataset. As smaller
components merge, this final component persists across all scales, since
nothing remains to connect with it.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pd</span>, asp <span class="op">=</span> <span class="fl">1</span>, diagLim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">.75</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="fl">0.6</span>, <span class="fl">0.4</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'Homology in degree 0'</span>,<span class="st">'Homology in degree 1'</span><span class="op">)</span>,</span>
<span>col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>, pch <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">19</span>,<span class="fl">2</span><span class="op">)</span>, cex <span class="op">=</span> <span class="fl">.8</span>, pt.lwd <span class="op">=</span> <span class="fl">2</span>, bty <span class="op">=</span> <span class="st">"n"</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-8-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="persistence-landscape-transformation">Persistence Landscape Transformation<a class="anchor" aria-label="anchor" href="#persistence-landscape-transformation"></a>
</h2>
<p>Now that we have persistence data, we can construct persistence
landscapes, which are useful for analyzing topological features in a
form suited for statistical methods. Persistence landscapes are built by
transforming persistence diagrams into a sequence of “tent” functions
that capture the lifetime of topological features.</p>
<div class="section level3">
<h3 id="tent-functions">Tent Functions<a class="anchor" aria-label="anchor" href="#tent-functions"></a>
</h3>
<p>Each point in the persistence diagram corresponds to a topological
feature with a birth and death time. We can represent these features
using tent functions:</p>
<ul>
<li>The base of the tent spans from the feature’s birth to its
death.</li>
<li>The peak of the tent is located at the midpoint between birth and
death.</li>
<li>The height of the tent at any point reflects how long the feature
persists around that time.</li>
</ul>
<p>These tent functions are given by:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mi>x</mi><mo>−</mo><msub><mi>b</mi><mi>i</mi></msub></mtd><mtd columnalign="left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><msub><mi>b</mi><mi>i</mi></msub><mo>&lt;</mo><mi>x</mi><mo>≤</mo><mfrac><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mtd></mtr><mtr><mtd columnalign="left"><mo>−</mo><mi>x</mi><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub></mtd><mtd columnalign="left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mfrac><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><mn>2</mn></mfrac><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msub><mi>d</mi><mi>i</mi></msub></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
f_{(b_i, d_i)}(x) = 
\begin{cases} 
x - b_i &amp; \text{if } b_i &lt; x \leq \frac{b_i + d_i}{2} \\ 
-x + d_i &amp; \text{if } \frac{b_i + d_i}{2} &lt; x &lt; d_i \\ 
0 &amp; \text{otherwise} 
\end{cases}
</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="levels">Levels<a class="anchor" aria-label="anchor" href="#levels"></a>
</h3>
<p>To create the persistence landscape, we superimpose these tent
functions. At each point on the timeline, the height of the landscape is
given by the level of these tents—the largest height at that point. The
level provides a layered structure:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_1(t)</annotation></semantics></math>
is the level that takes the value of the tallest tent at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_2(t)</annotation></semantics></math>
is the level that takes the value of the second tallest tent at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
and so on for the remaining less prominent features.</li>
<li>Generically,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>k</mi><mtext mathvariant="normal">th</mtext></msup></mrow><annotation encoding="application/x-tex">\lambda_k(t)=k^{\text{th}}</annotation></semantics></math>
largest value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="prefix">|</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mi>P</mi><mi>D</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{f_{(b_i, d_i)}(t) | (b_i, d_i) \in PD\}</annotation></semantics></math>
at each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">PD</annotation></semantics></math>
is the persistence diagram. This superimposition of tents, creating a
level of functions, allows us to visualize and analyze the relative
significance of topological features. The collection of our levels makes
our landscape.</li>
</ul>
<p>These levels help develop a geometric understanding of persistence
landscapes and should be helpful for when we think about the analysis
being done.</p>
<p>To begin working with the persistence landscape framework, {plt}
methods demands that our data is in a particular format,
<code><a href="../reference/as_persistence.html">as_persistence()</a></code> ensures this, if your data is in one of
the recognized formats/classes (see <a href="https://corybrunson.github.io/plt/reference/as_persistence.html" class="external-link">help
file</a>).</p>
<p>This function in {plt} has multiple methods to convert persistence
data to a format required for other {plt} functions. It can be applied
to a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>-column
matrix (or an object coercible to one) with columns dimension/degree,
start/birth, and end/death, though the columns need not be named, or it
can convert outputs from persistence data producing functions like
<code><a href="https://rdrr.io/pkg/TDA/man/alphaComplexDiag.html" class="external-link">alphaComplexDiag()</a></code>.</p>
<p>Note that <code><a href="../reference/as_persistence.html">as_persistence()</a></code> is called in
<code><a href="../reference/pl_new.html">pl_new()</a></code>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_persistence.html">as_persistence</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span></span>
<span><span class="co">#&gt; 'persistence' data computed up to degree 1:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; * 0-degree features: 60</span></span>
<span><span class="co">#&gt; * 1-degree features: 23</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; threshold = 0.147231</span></span></code></pre></div>
<p>The <code><a href="../reference/pl_new.html">pl_new()</a></code> function takes in a single matrix of
persistence data or a formatted list with the class
<code>persistence_diagram</code>, and computes the persistence
landscape. Below, we compute the landscape for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-dimensional
topological features.</p>
<p>Often users will find it useful to only look at one dimension of the
data, whether for simplification or if it’s a particular dimension of
interest. Below, we filter for only degree-one topological features and
the entire domain of the landscape by setting <code>xmin</code> and
<code>xmax</code> to the infimum and supremum, respectively. You can
select what window of filtration you want the landscape by changing
these parameters. The window must contain the <em>support</em> of the
landscape, which is the set of points for which the persistence
landscape is non-zero.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pl1d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pl_new.html">pl_new</a></span><span class="op">(</span><span class="va">pd</span>, degree <span class="op">=</span> <span class="fl">1</span>, xby <span class="op">=</span> <span class="fl">0.025</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">pl1d</span><span class="op">)</span></span>
<span><span class="co">#&gt; Internal representation:  discrete </span></span>
<span><span class="co">#&gt; Number of levels:  23 </span></span>
<span><span class="co">#&gt; Representation limits: ( 0 , 0.4 )  at resolution 0 </span></span>
<span><span class="co">#&gt; Landscape range: ( 0 , 0.10871 ) </span></span>
<span><span class="co">#&gt; Magnitude:  0.001612 </span></span>
<span><span class="co">#&gt; Integral:   0.022786</span></span></code></pre></div>
<p>The above function for the “tents” performs a transformation that
puts each feature in terms of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>b</mi><mo>+</mo><mi>d</mi></mrow><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{b+d}{2}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>d</mi><mo>−</mo><mi>b</mi></mrow><mn>2</mn></mfrac><annotation encoding="application/x-tex">\frac{d-b}{2}</annotation></semantics></math>,
making the graphical representation easier to visually understand. Note
that this is a discrete persistence landscape so it is generated by
sampling a number of points and interpolating to create a continuous
function.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n_levs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="../reference/pl_new.html">pl_num_levels</a></span><span class="op">(</span><span class="va">pl1d</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pl1d</span>, main <span class="op">=</span> <span class="st">"Persistence Landscape"</span>, n_levels <span class="op">=</span> <span class="va">n_levs</span>, asp <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-11-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="properties">Properties<a class="anchor" aria-label="anchor" href="#properties"></a>
</h3>
<p>A persistence landscape has the following properties which make it
directly usable for statistical analysis and machine learning:</p>
<ul>
<li>
<strong>Stability</strong>: Small perturbations in the input data
lead to small changes in the landscape, ensuring that results are robust
to noise.</li>
<li>
<strong>Linearity</strong>: Persistence landscapes live in a vector
space, allowing them to be meaningfully added, scaled, and
averaged.</li>
<li>
<strong>Inner Product Structure</strong>: This vector space is in
fact a Hilbert space, enabling the definition of distances, norms, and
inner products.</li>
<li>
<strong>Asymptotic Normality</strong>: Persistence landscapes
satisfy a central limit theorem, enabling the use of
normal-distribution-based inference for hypothesis testing and
confidence intervals.</li>
<li>
<strong>Vectorization</strong>: Landscapes can be vectorized, making
them easily manipulable and compatible with statistical and machine
learning pipelines.</li>
</ul>
</div>
<div class="section level3">
<h3 id="mean-persistence-landscape">Mean Persistence Landscape<a class="anchor" aria-label="anchor" href="#mean-persistence-landscape"></a>
</h3>
<p>A convenient way of thinking about the mean persistence landscape is
by considering its levels. To define a mean on landscapes, we take the
pointwise mean of each level. Hence, the mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>i</mi><mstyle mathvariant="double-struck"><mi>𝕥</mi><mi>𝕙</mi></mstyle></msup><annotation encoding="application/x-tex">i^{\mathbb{th}}</annotation></semantics></math>
level is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>λ</mi><mo accent="true">‾</mo></mover><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msubsup><mi>λ</mi><mi>i</mi><mi>j</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\bar \lambda_i(x) = \frac{1}{N}\sum_{j=1}^{N}\lambda_i ^j(x),</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is the index of the landscape, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is the number of landscapes. Overlaying these mean levels grants us the
mean persistence landscape.</p>
<p>Below, we noisily sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>
times from a lemniscate, and then compute the persistence landscape for
each sampled point cloud.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">101137L</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pl_list_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">6</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">pc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tdaverse.github.io/tdaunif/reference/lemniscates.html" class="external-link">sample_lemniscate_gerono</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">60</span>, sd <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span></span>
<span>  <span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/TDA/man/alphaComplexDiag.html" class="external-link">alphaComplexDiag</a></span><span class="op">(</span><span class="va">pc</span>, maxdimension <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">$</span><span class="va">diagram</span></span>
<span>  <span class="va">pd</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">pd</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">pl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pl_new.html">pl_new</a></span><span class="op">(</span><span class="va">pd</span>, degree <span class="op">=</span> <span class="fl">1</span>, xby <span class="op">=</span> <span class="fl">.01</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pl</span><span class="op">)</span></span>
<span>  <span class="va">pl_list_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">pl_list_1</span>, <span class="va">pl</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-12-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We then compute the mean persistence landscape of these
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>
persistence landscapes.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/arithmetic.html">pl_mean</a></span><span class="op">(</span><span class="va">pl_list_1</span><span class="op">)</span>, main <span class="op">=</span> <span class="st">"Mean Persistence Landscape"</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-13-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="applications-of-tda">Applications of TDA<a class="anchor" aria-label="anchor" href="#applications-of-tda"></a>
</h2>
<div class="section level3">
<h3 id="hypothesis-testing">Hypothesis Testing<a class="anchor" aria-label="anchor" href="#hypothesis-testing"></a>
</h3>
<p>In statistics, hypothesis tests are used to weigh the evidence
(collected data) to determine whether there is a real effect or
phenomenon present in the data, or if its simply a consequence of random
sampling or variation. When conducting a hypothesis test, we define a
<em>null hypothesis</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>
that predicates that no effect is present, and we define an alternative
hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mi>A</mi></msub><annotation encoding="application/x-tex">H_A</annotation></semantics></math>
that specifies the direction of a present effect. A hypothesis test
requires a calculated <em>test statistic</em> from the observed data,
and an understanding of the test statistic’s theoretical probability
distribution. A
<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value</em>
is the probability of obtaining a test statistic as extreme or more
extreme than the observed test statistic, assuming the null hypothesis
to be true. And
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
the <em>significance level</em>, is the probability of rejecting the
null hypothesis when it is actually true (<em>type I error</em>). This
value is typically set by the investigator ahead of time, conventionally
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.05</mn><annotation encoding="application/x-tex">0.05</annotation></semantics></math>.
If the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&lt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">p &lt; \alpha</annotation></semantics></math>,
then we <em>reject</em> our null hypothesis, otherwise we
<em>accept</em> or <em>fail to reject</em> it.</p>
<p>In TDA, we can use persistence landscapes to derive test statistics
in order to conduct hypotheses tests on samples of point cloud data. Our
{plt} hypothesis testing functions — <code><a href="../reference/inference.html">pl_z_test()</a></code> and
<code><a href="../reference/inference.html">pl_perm_test()</a></code> — provide the test result as a list
containing useful information like the estimated distance between the
mean landscapes, the test statistic, the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value,
and more. The list is assigned the <code>htest</code> class, which comes
with an elegant <code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> method.</p>
<p>For our next example, we will show how to test whether two
collections of point clouds were sampled from different distributions.
First, we create a counterfeit lemniscate sampler, which might be
similar enough to that of Gerono to, say, deceive a quality control
step. This counterfeit lemniscate is the union of differently-sized
circles, while the original has same-sized lobes, and it is sampled with
noise from the same distribution.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sample_nonsym_lemniscate</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">circle1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/TDA/man/circleUnif.html" class="external-link">circleUnif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">25</span>, r <span class="op">=</span> <span class="fl">.50</span><span class="op">)</span></span>
<span>  <span class="va">circle2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/TDA/man/circleUnif.html" class="external-link">circleUnif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">35</span>, r <span class="op">=</span> <span class="fl">.75</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">circle1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">circle1</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span>, <span class="va">circle1</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">circle2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">circle2</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">2.25</span>, <span class="va">circle2</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">circle1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tdaverse.github.io/tdaunif/reference/noise.html" class="external-link">add_noise</a></span><span class="op">(</span><span class="va">circle1</span>, sd <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span></span>
<span>  <span class="va">circle2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tdaverse.github.io/tdaunif/reference/noise.html" class="external-link">add_noise</a></span><span class="op">(</span><span class="va">circle2</span>, sd <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span></span>
<span>  <span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">circle1</span>, <span class="va">circle2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="fu">sample_nonsym_lemniscate</span><span class="op">(</span><span class="op">)</span>, asp <span class="op">=</span> <span class="fl">1</span>, pch <span class="op">=</span> <span class="fl">16</span>, xlab <span class="op">=</span> <span class="st">"x"</span>, ylab <span class="op">=</span> <span class="st">"y"</span>, main <span class="op">=</span> <span class="st">"Non-symmetric Figure Eight Point Cloud"</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-14-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We noisily sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>
times from the lemniscate sampler above, compute the persistence
landscape for each point cloud, and then plot the persistence
landscapes.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">194114L</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pl_list_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">6</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">pc</span> <span class="op">&lt;-</span> <span class="fu">sample_nonsym_lemniscate</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/TDA/man/alphaComplexDiag.html" class="external-link">alphaComplexDiag</a></span><span class="op">(</span><span class="va">pc</span>, maxdimension <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">$</span><span class="va">diagram</span></span>
<span>  <span class="va">pd</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">pd</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">pl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pl_new.html">pl_new</a></span><span class="op">(</span><span class="va">pd</span>, degree <span class="op">=</span> <span class="fl">1</span>, xby <span class="op">=</span> <span class="fl">.01</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pl</span><span class="op">)</span></span>
<span>  <span class="va">pl_list_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">pl_list_2</span>, <span class="va">pl</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-15-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We will refer to the sampling distributions, <code>pl_list_1</code>
and <code>pl_list_2</code>, as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>1</mn></msub><annotation encoding="application/x-tex">P_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>2</mn></msub><annotation encoding="application/x-tex">P_2</annotation></semantics></math>.
Below, we replot the mean persistence landscape of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>1</mn></msub><annotation encoding="application/x-tex">P_1</annotation></semantics></math>
(figure eight) and plot the mean persistence landscape of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>2</mn></msub><annotation encoding="application/x-tex">P_2</annotation></semantics></math>
(non-symmetric figure eight). We denote these mean landscapes as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>P</mi><mn>1</mn></msub><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{P_1}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>P</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{P_2}</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">0.25</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/arithmetic.html">pl_mean</a></span><span class="op">(</span><span class="va">pl_list_1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span><span class="st">"Mean PL of P1"</span>, adj <span class="op">=</span> <span class="fl">0.1</span>, line <span class="op">=</span> <span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/arithmetic.html">pl_mean</a></span><span class="op">(</span><span class="va">pl_list_2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span><span class="st">"Mean PL of P2"</span>, adj <span class="op">=</span> <span class="fl">0.1</span>, line <span class="op">=</span> <span class="op">-</span><span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-16-1.png" width="700" style="display: block; margin: auto;"></p>
<p>There is a visual difference between the landscapes, but we haven’t
quantified the strength of evidence for this difference.</p>
<p>We will use a two sample Z-test and a permutation test to determine
if there is a statistically significant difference between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>P</mi><mn>1</mn></msub><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{P_1}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>P</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover><annotation encoding="application/x-tex">\bar{P_2}</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="z-test">Z-Test<a class="anchor" aria-label="anchor" href="#z-test"></a>
</h3>
<p>The purpose of a <strong>two sample Z-test</strong> is to test for
the difference of means between two samples from two population
distributions. The Z-test is a parametric test that requires the two
samples to be normally distributed and performs well when you have large
sample sizes and known population variances. If these assumptions are
not met, then the test is inappropriate.</p>
<p>To conduct this test on persistent landscapes, the test statistic
requires a functional, the integral of the mean persistent landscape, to
quantify the difference in mean persistence landscapes. The interval of
this integration is determined by the <code>support</code> provided from
the user. Specifically, users can enter intervals for the
<code>support</code> parameter to focus on regions where important
topological features lie, which would increase computational efficiency.
The test statistic is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mfrac><mrow><mover><msub><mi>P</mi><mn>1</mn></msub><mo accent="true">‾</mo></mover><mo>−</mo><mover><msub><mi>P</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover></mrow><msqrt><mrow><mfrac><msubsup><mi>S</mi><msub><mi>P</mi><mn>1</mn></msub><mn>2</mn></msubsup><msub><mi>n</mi><mn>1</mn></msub></mfrac><mo>+</mo><mfrac><msubsup><mi>S</mi><msub><mi>P</mi><mn>2</mn></msub><mn>2</mn></msubsup><msub><mi>n</mi><mn>2</mn></msub></mfrac></mrow></msqrt></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">z = \frac{\bar{P_1}-\bar{P_2}}{\sqrt{\frac{S^2_{P_1}}{n_1}+\frac{S^2_{P_2}}{n_2}}},</annotation></semantics></math></p>
<p>where the denominator is the standard error for the difference and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">z \sim N(0,1)</annotation></semantics></math>.
For more information, please reference section 3 of Bubenik (2015).</p>
<p>In our example, the null hypothesis is that there is not a difference
in the two mean persistence landscapes, which would imply that they both
came from the same population distribution. And the alternative
hypothesis is that there is a difference between the mean persistence
landscapes. Succinctly, we test
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mover><msub><mi>P</mi><mn>1</mn></msub><mo accent="true">‾</mo></mover><mo>−</mo><mover><msub><mi>P</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_0: \bar{P_1}-\bar{P_2} = 0</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">vs</mtext><annotation encoding="application/x-tex">\text{vs}</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>A</mi></msub><mo>:</mo><mover><msub><mi>P</mi><mn>1</mn></msub><mo accent="true">‾</mo></mover><mo>−</mo><mover><msub><mi>P</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">H_A: \bar{P_1}-\bar{P_2} \ne 0</annotation></semantics></math>.</p>
<p>We can adjust
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
by changing the <code>conf.level</code>. Here, we will use the default
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.95</mn><annotation encoding="application/x-tex">0.95</annotation></semantics></math>
confidence level, so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\alpha=0.05</annotation></semantics></math>.
Also, the user can adjust the direction of the alternative hypothesis by
setting the <code>alternative</code> argument to “two.sided” (default),
“greater” or “less”.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span><span class="va">ztest</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/inference.html">pl_z_test</a></span><span class="op">(</span><span class="va">pl_list_1</span>, <span class="va">pl_list_2</span>, alternative <span class="op">=</span> <span class="st">"two.sided"</span>, conf.level <span class="op">=</span> <span class="fl">0.95</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  z-test</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; data:  </span></span>
<span><span class="co">#&gt; z = -2.3495, df = 10, p-value = 0.0188</span></span>
<span><span class="co">#&gt; alternative hypothesis: true difference in means is not equal to 0</span></span>
<span><span class="co">#&gt; 95 percent confidence interval:</span></span>
<span><span class="co">#&gt;  -0.049991074 -0.004518401</span></span>
<span><span class="co">#&gt; sample estimates:</span></span>
<span><span class="co">#&gt; mean integral of x mean integral of y </span></span>
<span><span class="co">#&gt;         0.02177963         0.04903436</span></span></code></pre></div>
<p>Since the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.019</mn><annotation encoding="application/x-tex">0.019</annotation></semantics></math>,
we reject the null hypothesis. This result suggests that, according to
the Z-test, the samples appear to come from the different distributions,
though the evidence was not as strong as we might want. This highlights
the Z-test’s conservative nature when testing for differences between
two samples of persistence landscapes, especially when we have small
sample sizes.</p>
</div>
<div class="section level3">
<h3 id="permutation-test">Permutation Test<a class="anchor" aria-label="anchor" href="#permutation-test"></a>
</h3>
<p>We now perform a <strong>permutation test</strong>, which is a
non-parametric hypothesis test. This test is useful for smaller sample
sizes and does not require an assumption of distribution of the data.
Specifically, the principle assumption of the permutation test is that
the observations (in our case, the persistence landscapes) do not come
from two distinct population distributions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><msub><mi>P</mi><mn>1</mn></msub></msub><annotation encoding="application/x-tex">F_{P_1}</annotation></semantics></math>
&amp;
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><msub><mi>P</mi><mn>2</mn></msub></msub><annotation encoding="application/x-tex">F_{P_2}</annotation></semantics></math>,
and that they are <em>completely exchangeable</em> across the two
groups.</p>
<p>The first step of the permutation test is to calculate an initial
test statistic. For our data, it will be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mover><msub><mi>P</mi><mn>1</mn></msub><mo accent="true">‾</mo></mover><mo>−</mo><mover><msub><mi>P</mi><mn>2</mn></msub><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">K = \bar{P_1}-\bar{P_2}</annotation></semantics></math>.
We build the sampling distribution by rearranging our
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>12</mn><annotation encoding="application/x-tex">12</annotation></semantics></math>
samples
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>
each from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>1</mn></msub><annotation encoding="application/x-tex">P_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>2</mn></msub><annotation encoding="application/x-tex">P_2</annotation></semantics></math>)
and computing the test statistic for each permutation. We then compare
the initial test statistic to the distribution of test statistics we
obtained by randomly permuting the data. This helps to determine whether
the observed effect is statistically significant.</p>
<p>The null hypothesis is that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>1</mn></msub><annotation encoding="application/x-tex">P_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>2</mn></msub><annotation encoding="application/x-tex">P_2</annotation></semantics></math>
come from the same distribution and the alternative hypothesis being
that they do not come from the same population distribution. Succinctly,
we test
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><msub><mi>F</mi><msub><mi>P</mi><mn>1</mn></msub></msub><mo>=</mo><msub><mi>F</mi><msub><mi>P</mi><mn>2</mn></msub></msub></mrow><annotation encoding="application/x-tex">H_0: F_{P_1} = F_{P_2}</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">vs</mtext><annotation encoding="application/x-tex">\text{vs}</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>A</mi></msub><mo>:</mo><msub><mi>F</mi><msub><mi>P</mi><mn>1</mn></msub></msub><mo>≠</mo><msub><mi>F</mi><msub><mi>P</mi><mn>2</mn></msub></msub></mrow><annotation encoding="application/x-tex">H_A: F_{P_1} \ne F_{P_2}</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span><span class="va">perm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/inference.html">pl_perm_test</a></span><span class="op">(</span><span class="va">pl_list_1</span>, <span class="va">pl_list_2</span>, complete <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  permutation test</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; data:  </span></span>
<span><span class="co">#&gt; p-value = 0.002165</span></span>
<span><span class="co">#&gt; alternative hypothesis: true distance between mean landscapes is greater than 0</span></span>
<span><span class="co">#&gt; sample estimates:</span></span>
<span><span class="co">#&gt; distance between mean landscapes </span></span>
<span><span class="co">#&gt;                       0.06887439</span></span></code></pre></div>
<p>Since the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.0022</mn><annotation encoding="application/x-tex">0.0022</annotation></semantics></math>,
we again reject the null hypothesis. This
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-value
was an order of magnitude smaller than that obtained from the two sample
Z-test. These two hypothesis tests are looking at the data in different
ways, so one test may detect the topological (or geometric) difference
between the samples more effectively than the other.</p>
</div>
<div class="section level3">
<h3 id="exploratory-dimension-reduction">Exploratory Dimension Reduction<a class="anchor" aria-label="anchor" href="#exploratory-dimension-reduction"></a>
</h3>
<p>In this section, we conduct exploratory analysis using variance
decomposition. This is done to reduce the dimensions of our data while
retaining as much variance as possible. We will use <strong>principal
components analysis</strong> (PCA), which transforms the given variables
into a new set of uncorrelated variables called <em>principal
components</em>. These components are ordered by the amount of variance
they capture from the data, with the first component capturing the most
variance, and each subsequent component capturing progressively less. We
apply PCA to the vectorized forms of the persistence landscapes.</p>
<p>We continue using the lists from our example. We utilize the
<code><a href="../reference/algebra.html">pl_to_matrix()</a></code> function, which converts our persistence
landscapes into matrix format, allowing us to perform general-purpose
data analytic operations on them. <code><a href="https://rdrr.io/r/stats/prcomp.html" class="external-link">prcomp()</a></code> performs PCA on
our vectorized persistence landscapes.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pl_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">pl_list_1</span>,<span class="va">pl_list_2</span><span class="op">)</span></span>
<span><span class="va">pl_vectors</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/algebra.html">pl_to_matrix</a></span><span class="op">(</span><span class="va">pl_list</span><span class="op">)</span></span>
<span><span class="va">pca</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/prcomp.html" class="external-link">prcomp</a></span><span class="op">(</span><span class="va">pl_vectors</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pca</span>, type <span class="op">=</span> <span class="st">"l"</span>, main <span class="op">=</span> <span class="st">"Scree Plot"</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-21-1.png" width="700" style="display: block; margin: auto;"></p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">pca</span><span class="op">)</span></span>
<span><span class="co">#&gt; Importance of components:</span></span>
<span><span class="co">#&gt;                           PC1    PC2     PC3     PC4     PC5     PC6     PC7</span></span>
<span><span class="co">#&gt; Standard deviation     0.3681 0.1559 0.10456 0.03776 0.03496 0.02385 0.02245</span></span>
<span><span class="co">#&gt; Proportion of Variance 0.7749 0.1390 0.06254 0.00815 0.00699 0.00325 0.00288</span></span>
<span><span class="co">#&gt; Cumulative Proportion  0.7749 0.9140 0.97649 0.98465 0.99164 0.99489 0.99777</span></span>
<span><span class="co">#&gt;                            PC8     PC9     PC10     PC11      PC12</span></span>
<span><span class="co">#&gt; Standard deviation     0.01361 0.01097 0.007923 0.004584 4.883e-17</span></span>
<span><span class="co">#&gt; Proportion of Variance 0.00106 0.00069 0.000360 0.000120 0.000e+00</span></span>
<span><span class="co">#&gt; Cumulative Proportion  0.99883 0.99952 0.999880 1.000000 1.000e+00</span></span></code></pre></div>
<p>In the summary above, we see that about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>77.5</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">77.5\%</annotation></semantics></math>
of the variance in the original data is captured in the first principal
component, and about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13.9</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">13.9\%</annotation></semantics></math>
of the variance is captured in the second principal component. So the
first and second principal component are sufficient to explain the
variance of the data.</p>
<p>To evaluate whether the dimension reduction was successful, we assign
labels to our data based on the distribution they were generated from
and plot each sample with their corresponding first principal component
and second principal component values to see if any clustering or
patterns occurred.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data.labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pl_list_1</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">pl_list_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/plot.html">plot</a></span><span class="op">(</span><span class="va">pca</span><span class="op">$</span><span class="va">x</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, col <span class="op">=</span> <span class="va">data.labels</span>, pch <span class="op">=</span> <span class="fl">17</span> <span class="op">+</span> <span class="op">(</span><span class="fl">2</span> <span class="op">*</span> <span class="va">data.labels</span><span class="op">)</span>, asp <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="overview_files/figure-html/unnamed-chunk-22-1.png" width="700" style="display: block; margin: auto;"></p>
<p>As we can see, clustering of samples from the same sample did occur.
We observe that the between-group variance is mainly contained in the
first principal component. Also, the within-group variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>1</mn></msub><annotation encoding="application/x-tex">P_1</annotation></semantics></math>
is smaller than the between-group variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>2</mn></msub><annotation encoding="application/x-tex">P_2</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="classification">Classification<a class="anchor" aria-label="anchor" href="#classification"></a>
</h3>
<p>We now build a machine learning model to classify the point clouds
using their vectorized persistence landscapes. A <strong>support vector
machine</strong> (SVM) is a supervised algorithm commonly used for
classification tasks. It works by finding the optimal hyperplane that
best separates the classes
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>1</mn></msub><annotation encoding="application/x-tex">P_1</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>2</mn></msub><annotation encoding="application/x-tex">P_2</annotation></semantics></math>)
in the feature space (where each dimension of the feature space
corresponds to one of the elements in these vectors), maximizing the
margin between the closest data points of each class, known as support
vectors.</p>
<p>Below we train our model using <code><a href="https://rdrr.io/pkg/e1071/man/svm.html" class="external-link">svm()</a></code> and perform
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>-fold
<em>cross validation</em>. That is, the algorithm splits the data into
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>
groups and as it iterates to using each group as the testing group, it
uses the other
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>
groups as the training data. We set <code>scale = FALSE</code> so that
more persistent features have more weight.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">svm_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/e1071/man/svm.html" class="external-link">svm</a></span><span class="op">(</span><span class="va">pl_vectors</span>,<span class="va">data.labels</span>,scale <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>                 type <span class="op">=</span> <span class="st">"C-classification"</span>, kernel <span class="op">=</span> <span class="st">"linear"</span>, cost <span class="op">=</span> <span class="fl">10</span>, cross <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">svm_model</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; svm.default(x = pl_vectors, y = data.labels, scale = FALSE, type = "C-classification", </span></span>
<span><span class="co">#&gt;     kernel = "linear", cost = 10, cross = 4)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Parameters:</span></span>
<span><span class="co">#&gt;    SVM-Type:  C-classification </span></span>
<span><span class="co">#&gt;  SVM-Kernel:  linear </span></span>
<span><span class="co">#&gt;        cost:  10 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of Support Vectors:  3</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  ( 1 2 )</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of Classes:  2 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Levels: </span></span>
<span><span class="co">#&gt;  1 2</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; 4-fold cross-validation on training data:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Total Accuracy: 100 </span></span>
<span><span class="co">#&gt; Single Accuracies:</span></span>
<span><span class="co">#&gt;  100 100 100 100</span></span></code></pre></div>
<p>The model successfully distinguishes between the different
topological structures present in the two persistence landscapes.</p>
</div>
</div>
<div class="section level2">
<h2 id="supporting-information">Supporting Information<a class="anchor" aria-label="anchor" href="#supporting-information"></a>
</h2>
<div class="section level3">
<h3 id="appendix">Appendix<a class="anchor" aria-label="anchor" href="#appendix"></a>
</h3>
<p>A
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-simplex</strong>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-dimensional
polytope which is the convex hull of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math>
points in Euclidean space in general position (the points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_1,...,x_{k+1}</annotation></semantics></math>
are <em>affinely independent</em>, which means that the vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_2-x_1,...,x_{k+1}-x_1</annotation></semantics></math>
are linearly independent). The convex hull of a non-empty subset of
these points is called the <em>face</em> of the simplex.</p>
<p>A <strong>simplicial complex</strong> is a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
of simplices such that</p>
<ul>
<li><p>the face of any simplex in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
is also in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>;
and</p></li>
<li><p>any non-empty intersection of two simplices is a face of both of
them.</p></li>
</ul>
<p>An <strong>abstract simplicial complex</strong> is a set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
of non-empty subsets of a fixed set such that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">A \in K</annotation></semantics></math>,
then all nonempty subsets of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
are also in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>.</p>
<p>For a finite set of points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊂</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mi>d</mi></msup></mrow><annotation encoding="application/x-tex">X \subset \mathbb{R}^d</annotation></semantics></math>,
the <strong>Alpha complex</strong>
Alpha<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X,s)</annotation></semantics></math>
is a simplicial subcomplex of the Delaunay complex of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
consisting of simplices of circumradius less than or equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msqrt><mi>s</mi></msqrt><annotation encoding="application/x-tex">\sqrt{s}</annotation></semantics></math>.
The Alpha complex is defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">Alpha</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>σ</mi><mo>⊂</mo><mi>X</mi><mo>:</mo><munder><mo>⋂</mo><mrow><mi>u</mi><mo>∈</mo><mi>σ</mi></mrow></munder><msub><mi>R</mi><mi>u</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msqrt><mi>s</mi></msqrt><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mi>∅</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex"> 
\text{Alpha}(X, r) = \{ \sigma \subset X : \bigcap_{u \in \sigma} R_u(\sqrt{s}) \neq \emptyset \}.
</annotation></semantics></math></p>
<p>A <strong>filtered simplicial complex</strong> consists of a nested
sequence of simplicial complexes:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mn>0</mn></msub><mo>⊂</mo><msub><mi>K</mi><mn>1</mn></msub><mo>⊂</mo><msub><mi>K</mi><mn>2</mn></msub><mo>⊂</mo><mspace width="0.278em"></mspace><mi>.</mi><mi>.</mi><mi>.</mi><mo>⊂</mo><msub><mi>K</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">
K_0 \subset K_1 \subset K_2 \subset \;...\subset K_n
</annotation></semantics></math></p>
<p>Applying homology, we obtain a sequence of vector spaces and linear
maps called a <strong>persistence module</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mspace width="0.278em"></mspace><mi>.</mi><mi>.</mi><mi>.</mi><mo>→</mo><msub><mi>H</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
H_k(K_0) \rightarrow H_k(K_1) \rightarrow H_k(K_2) \rightarrow \;...\rightarrow H_k(K_n)
</annotation></semantics></math> The images of these maps and
compositions of these maps are called <strong>persistence
homology</strong> vector spaces.</p>
<p>A <strong>persistence module</strong>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
consists of a vector space
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>M</mi><mi>a</mi></msub><annotation encoding="application/x-tex">M_a</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">a \in \mathbb{R}</annotation></semantics></math>
and linear maps
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:</mo><msub><mi>M</mi><mi>a</mi></msub><mo>→</mo><msub><mi>M</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">M(a\leq b):M_a \to M_b</annotation></semantics></math>
for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leq b</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>≤</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">M(a \leq a)</annotation></semantics></math>
is the identity map and for all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mi>c</mi><mo>,</mo><mspace width="0.278em"></mspace><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>≤</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∘</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>≤</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a \leq b \leq c, \; M(b \leq c) \circ M(a \leq b) = M (a \leq c)</annotation></semantics></math>.</p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
be a persistence module and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i \leq d_i</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mi>i</mi></msub><annotation encoding="application/x-tex">b_i</annotation></semantics></math>
is some birth value and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mi>i</mi></msub><annotation encoding="application/x-tex">d_i</annotation></semantics></math>
is some death value. The <strong>betti number</strong> of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>
is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>β</mi><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>d</mi><mi>i</mi></msub></mrow></msup><mo>=</mo><mo>dim</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">im</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>b</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\beta^{b_i, d_i} = \dim(\text{im}(M(b_i \leq d_i)))
</annotation></semantics></math></p>
<p>The
<strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>k</mi><mrow><mi>t</mi><mi>h</mi></mrow></msup><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math>
Betti number</strong>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\beta_k</annotation></semantics></math>,
counts the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-dimensional
features of a simplicial complex. For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\beta_0</annotation></semantics></math>
counts the number of connected components and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math>
counts the number of holes.</p>
<p>The <strong>rank function</strong>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>:</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><mo>→</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\lambda: \mathbb{R}^2 \rightarrow \mathbb{R}</annotation></semantics></math>
defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>λ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><msup><mstyle mathvariant="double-struck"><mi>β</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></mtd><mtd columnalign="left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>d</mi><mo>≥</mo><mi>b</mi></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\mathbb{\lambda}(b, d) = 
\begin{cases}
    \mathbb{\beta}^{(b,d)} &amp; \text{if } d \geq b \\
    0 &amp; \text{otherwise}
\end{cases}
</annotation></semantics></math></p>
<p>Now, we change the coordinate system from (birth, death) scale to the
(midlife, halflife) scale for ease of interpretability and analysis. We
have:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>d</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></mfrac><mspace width="0.278em"></mspace><mtext mathvariant="normal">and</mtext><mspace width="0.278em"></mspace><mi>h</mi><mo>=</mo><mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mo>−</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
m = \frac{(b + d)}{ 2} \;  \text{and} \;h = \frac{(d-b)}{2}.
</annotation></semantics></math> Hence our <strong>rescaled rank
function</strong>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>λ</mi></mstyle><mo>:</mo><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><mo>→</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathbb{\lambda}: \mathbb{R}^2 \rightarrow \mathbb{R}</annotation></semantics></math>,
defined as:<br><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="double-struck"><mi>λ</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><msup><mstyle mathvariant="double-struck"><mi>β</mi></mstyle><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>−</mo><mi>h</mi><mo>,</mo><mi>m</mi><mo>+</mo><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup></mtd><mtd columnalign="left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>h</mi><mo>≥</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
\mathbb{\lambda}(m, h) = 
\begin{cases}
    \mathbb{\beta}^{(m-h,m+h)} &amp; \text{if } h \geq 0 \\
    0 &amp; \text{otherwise}
\end{cases}
</annotation></semantics></math>.</p>
<p>Finally, the <strong>persistence landscape</strong> is a function,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><mo>×</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\lambda: \mathbb{N} \times \mathbb{R} \rightarrow \mathbb{R}</annotation></semantics></math>.
Or it could be thought of as a sequence of functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle></mrow><annotation encoding="application/x-tex">\lambda_k: \mathbb{R} \to \mathbb{R}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_k(t) = \lambda(k,t)</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_k(t)</annotation></semantics></math>
is defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>sup</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>≥</mo><mn>0</mn><mo stretchy="false" form="prefix">|</mo><msup><mi>β</mi><mrow><mi>t</mi><mo>−</mo><mi>m</mi><mo>,</mo><mi>t</mi><mo>+</mo><mi>m</mi></mrow></msup><mo>≥</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\lambda_k(t) = \sup(m \geq 0 | \beta^{t-m, t+m} \geq k)
</annotation></semantics></math> Essentially,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\lambda_k(t)</annotation></semantics></math>
finds the largest interval around t where there at least
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
persistent features.</p>
</div>
<div class="section level3">
<h3 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h3>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>Bubenik, Peter. “Statistical Topological Data Analysis
Using Persistence Landscapes.” <em>Journal of Machine Learning
Research</em>, vol. 16, 2015, pp. 77-102.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><a href="https://people.clas.ufl.edu/peterbubenik/intro-to-tda/" class="external-link uri">https://people.clas.ufl.edu/peterbubenik/intro-to-tda/</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Jason Cory Brunson, James Golabek, Aidan Bryant, Jose Bouza, Paweł Dłotko.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

      </footer>
</div>






  </body>
</html>
